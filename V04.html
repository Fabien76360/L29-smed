<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SMED L29 – Suivi changement de PO</title>
<style>
:root {
  --bg:#0f1a34;
  --panel:#172447;
  --fg:#e8eefc;
  --accent:#3ddc97;
  --warn:#ffb703;
  --danger:#ef476f;
  --muted:#7b87a6;
  --shadow:0 20px 40px rgba(7,14,33,.55);
  --radius-xl:28px;
  --radius-lg:20px;
  --radius:14px;
  --radius-sm:10px;
  --focus:0 0 0 3px rgba(61,220,151,.35);
  color-scheme:dark;
}
* { box-sizing:border-box; }
html,body { height:100%; }
body {
  margin:0;
  font-family:"Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
  background:radial-gradient(140% 140% at 50% 0%,#1a2b55 0%,#0f1a34 45%,#09112a 100%);
  color:var(--fg);
}
button,input,select,textarea { font:inherit; color:inherit; }
button:focus-visible, input:focus-visible, select:focus-visible, textarea:focus-visible, a:focus-visible {
  outline:3px solid var(--accent);
  outline-offset:2px;
}
.app {
  min-height:100%;
  display:grid;
  grid-template-rows:auto 1fr;
}
header {
  padding:20px clamp(16px,3vw,40px) 0;
}
.top-nav {
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.header-actions {
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:12px;
  margin-left:auto;
}
.brand {
  font-weight:700;
  letter-spacing:0.12em;
  text-transform:uppercase;
  color:var(--muted);
  font-size:0.8rem;
}
.nav-tabs {
  display:flex;
  gap:12px;
}
.nav-tabs button {
  background:transparent;
  border:1px solid rgba(255,255,255,.12);
  color:var(--fg);
  border-radius:999px;
  padding:10px 18px;
  cursor:pointer;
  transition:background .2s ease, transform .2s ease, border-color .2s ease;
  min-width:120px;
}
.nav-tabs button.active {
  background:var(--accent);
  color:#021221;
  border-color:transparent;
  transform:translateY(-1px);
}
main {
  padding:0 clamp(16px,3vw,40px) 40px;
  display:grid;
}
.page {
  display:none;
}
.page.active {
  display:grid;
  gap:24px;
}
.timer-grid {
  display:grid;
  gap:24px;
}
@media (min-width:1200px) {
  .timer-grid {
    grid-template-columns: minmax(0,1fr) 360px;
  }
}
body.journal-hidden #journalAside {
  display:none;
}
body.journal-hidden .timer-grid {
  grid-template-columns:1fr !important;
}
.panel {
  background:rgba(23,36,71,.86);
  border:1px solid rgba(255,255,255,.06);
  border-radius:var(--radius-xl);
  padding:24px;
  box-shadow:var(--shadow);
  backdrop-filter:blur(16px);
}
.panel.compact { padding:18px; border-radius:var(--radius-lg); }
.panel-title {
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:16px;
  margin-bottom:18px;
}
.panel-title h2 {
  margin:0;
  font-size:1.1rem;
  letter-spacing:.02em;
}
.grid-two {
  display:grid;
  gap:16px;
}
@media (min-width:840px) {
  .grid-two {
    grid-template-columns:repeat(2,minmax(0,1fr));
  }
}
.id-row {
  display:grid;
  gap:12px;
  grid-template-columns:repeat(auto-fit,minmax(180px,1fr));
}
.field label {
  display:grid;
  gap:6px;
  font-size:0.76rem;
  text-transform:uppercase;
  letter-spacing:0.08em;
  color:var(--muted);
}
.field input, .field select {
  border-radius:var(--radius);
  border:1px solid rgba(255,255,255,.12);
  background:rgba(15,26,52,.65);
  padding:12px 14px;
  min-height:48px;
}
.field input[readonly] {
  opacity:.7;
}
.timer-shell {
  display:grid;
  gap:24px;
}
.timer-top {
  display:grid;
  gap:20px;
}
.timer-bar {
  display:flex;
  flex-wrap:wrap;
  align-items:stretch;
  justify-content:center;
  gap:18px;
}
.timer-bar > * {
  flex:1 1 260px;
}
.main-actions {
  display:flex;
  flex:2 1 320px;
  gap:12px;
  flex-wrap:wrap;
  justify-content:center;
  align-items:stretch;
}
.main-actions button {
  flex:1 1 160px;
  min-height:52px;
}
@media (max-width:1279px) {
  .main-actions {
    flex-direction:column;
    align-items:stretch;
  }
  .main-actions button {
    width:100%;
  }
}
@media (max-width:900px) {
  .timer-bar > * {
    flex:1 1 100%;
  }
}
.round-pill {
  background:rgba(9,18,40,.85);
  border:1px solid rgba(255,255,255,.08);
  border-radius:999px;
  padding:12px 20px;
  display:grid;
  gap:6px;
  text-align:center;
  min-width:220px;
}
.round-pill strong {
  font-size:1.2rem;
  letter-spacing:.05em;
}
#display {
  font-variant-numeric:tabular-nums;
  font-size:3rem;
  line-height:1;
  font-weight:700;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:16px;
  border-radius:999px;
  background:linear-gradient(140deg,rgba(13,28,61,.8),rgba(61,220,151,.12));
  border:1px solid rgba(61,220,151,.35);
  padding:20px 32px;
}
#display small {
  font-size:0.8rem;
  color:var(--muted);
}
.main-actions {
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  gap:12px;
}
button.primary {
  background:var(--accent);
  color:#021221;
  font-weight:700;
}
button.secondary {
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.16);
  color:var(--fg);
}
button.danger { background:var(--danger); border-color:transparent; }
button.warn { background:var(--warn); border-color:transparent; color:#051933; }
button.ghost { background:transparent; border:1px solid rgba(255,255,255,.18); }
button {
  border-radius:var(--radius);
  border:none;
  padding:12px 18px;
  font-weight:600;
  cursor:pointer;
  min-height:48px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  transition:transform .2s ease, background .2s ease;
}
button:disabled {
  cursor:not-allowed;
  opacity:.5;
  transform:none !important;
}
button:not(:disabled):active { transform:translateY(1px); }
.icon { font-family:"Fira Code", monospace; font-size:1rem; }
.progress-bar {
  width:100%;
  height:14px;
  background:rgba(255,255,255,.08);
  border-radius:999px;
  overflow:hidden;
}
.progress-value {
  width:0%;
  height:100%;
  background:var(--accent);
  transition:width .2s ease, background .2s ease;
}
#state { text-transform:uppercase; letter-spacing:0.12em; font-size:0.75rem; color:var(--muted); text-align:center; }
#now { font-variant-numeric:tabular-nums; font-size:0.85rem; color:var(--muted); text-align:right; }
.badge {
  border-radius:999px;
  padding:6px 12px;
  font-size:0.75rem;
  letter-spacing:0.08em;
  text-transform:uppercase;
  background:rgba(255,255,255,.12);
  color:var(--muted);
  display:inline-flex;
  align-items:center;
  gap:6px;
}
.badge.hc { background:rgba(255,255,255,.08); color:var(--warn); border:1px solid rgba(255,183,3,.4); }
#progress { margin-top:-12px; }
.phase-chips {
  display:flex;
  flex-wrap:wrap;
  gap:10px;
}
.phase-chip {
  background:rgba(15,26,52,.8);
  border:1px solid rgba(255,255,255,.12);
  color:var(--fg);
  padding:10px 18px;
  border-radius:999px;
  cursor:pointer;
  min-height:48px;
  display:flex;
  align-items:center;
  gap:8px;
  transition:transform .2s ease, border-color .2s ease, background .2s ease;
}
.phase-chip.active {
  background:var(--accent);
  color:#021221;
  border-color:transparent;
}
.phase-chip .dot {
  width:10px;
  height:10px;
  border-radius:999px;
  background:rgba(255,255,255,.3);
}
.phase-chip[data-phase="Prépa chgt de PO"] .dot { background:var(--warn); }
.phase-chip[data-phase="Début de PO"] .dot { background:#7ad3ff; }
.phase-chip[data-phase="Fin de PO"] .dot { background:#9b8dff; }
.phase-chip[data-phase="Vide de ligne"] .dot { background:#ff7ad9; }
.ops-columns {
  display:grid;
  gap:16px;
}
@media (min-width:960px) {
  .ops-columns {
    grid-template-columns:repeat(auto-fit,minmax(200px,1fr));
  }
}
.operator-card {
  background:rgba(9,18,40,.7);
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius-lg);
  padding:18px;
  display:grid;
  gap:16px;
  min-height:220px;
}
.operator-card.focused {
  border-color:var(--accent);
  box-shadow:0 0 0 2px rgba(61,220,151,.35);
}
.operator-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
}
.operator-header h3 {
  margin:0;
  font-size:1rem;
}
.operator-header .progress-text { font-size:0.75rem; letter-spacing:0.08em; color:var(--muted); }
.op-list {
  display:flex;
  flex-direction:column;
  gap:10px;
}
.op-pill {
  display:flex;
  align-items:center;
  gap:10px;
  padding:12px 14px;
  border-radius:var(--radius);
  border:1px solid rgba(255,255,255,.08);
  background:rgba(23,36,71,.8);
  cursor:pointer;
  position:relative;
  min-height:48px;
  transition:transform .2s ease, background .2s ease, border-color .2s ease;
}
.op-pill .index {
  width:28px;
  height:28px;
  border-radius:999px;
  background:rgba(255,255,255,.1);
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:600;
}
.op-pill.current {
  border-color:var(--accent);
  outline:2px solid rgba(61,220,151,.35);
  transform:scale(1.08);
}
.op-pill.done {
  background:rgba(61,220,151,.15);
  border-color:rgba(61,220,151,.6);
  transform:scale(0.84);
  color:var(--accent);
}
.op-pill.done .index { background:rgba(61,220,151,.45); color:#021221; }
.op-pill.done .check { display:inline; }
.check { display:none; font-weight:700; }
.log-table-wrapper {
  max-height:420px;
  overflow:auto;
  border-radius:var(--radius-lg);
  border:1px solid rgba(255,255,255,.1);
}
table { width:100%; border-collapse:collapse; font-size:0.9rem; }
th,td {
  padding:12px 14px;
  border-bottom:1px solid rgba(255,255,255,.05);
}
th {
  position:sticky;
  top:0;
  background:rgba(12,22,46,.95);
  text-align:left;
  font-size:0.75rem;
  letter-spacing:0.08em;
  text-transform:uppercase;
}
tbody tr:hover { background:rgba(255,255,255,.04); }
td.note-cell {
  min-width:200px;
}
td.note-cell[contenteditable="true"] {
  outline:none;
}
tfoot td { font-weight:700; }
.label-muted { color:var(--muted); font-size:0.8rem; }
.actions-row {
  display:flex;
  flex-wrap:wrap;
  gap:12px;
}
#fullscreen {
  justify-self:flex-end;
}
.chip-row {
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
.chip {
  padding:10px 16px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.1);
  background:rgba(255,255,255,.06);
  cursor:pointer;
}
.chip.active {
  background:var(--accent);
  color:#021221;
  border-color:transparent;
}
.toast-container {
  position:fixed;
  bottom:24px;
  right:24px;
  display:grid;
  gap:12px;
  z-index:2000;
}
.toast {
  background:rgba(15,26,52,.92);
  border:1px solid rgba(61,220,151,.35);
  border-radius:var(--radius);
  padding:12px 16px;
  min-width:220px;
  box-shadow:var(--shadow);
  display:flex;
  align-items:center;
  gap:12px;
}
.toast .icon { color:var(--accent); }
.tag { padding:4px 10px; border-radius:999px; background:rgba(255,255,255,.1); font-size:0.7rem; letter-spacing:0.08em; }
/* Parameters */
.section-group { display:grid; gap:20px; }
.general-panel { display:grid; gap:20px; }
.general-settings-bar {
  display:flex;
  flex-wrap:wrap;
  gap:16px;
  align-items:stretch;
}
.param-tile {
  background:rgba(15,26,52,.78);
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius-lg);
  padding:18px;
  display:grid;
  gap:12px;
  min-width:220px;
  flex:1 1 240px;
}
.param-tile h3 {
  margin:0;
  font-size:0.85rem;
  text-transform:uppercase;
  letter-spacing:0.08em;
  color:var(--muted);
}
.general-actions {
  margin-left:auto;
  display:flex;
  flex-direction:column;
  gap:12px;
  align-self:stretch;
  justify-content:flex-end;
}
.events-panel { display:grid; gap:16px; }
.event-form {
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  align-items:flex-end;
}
.event-form .field { flex:1 1 240px; }
.event-form button { align-self:flex-end; min-height:48px; }
.events-list {
  list-style:none;
  margin:0;
  padding:0;
  display:grid;
  gap:10px;
}
.events-list li {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  background:rgba(9,18,40,.6);
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius);
  padding:10px 14px;
}
.events-list li span { flex:1; }
.events-list li button {
  border:1px solid rgba(255,255,255,.12);
  border-radius:999px;
  padding:6px 12px;
  background:rgba(255,255,255,.06);
  cursor:pointer;
}
.events-list li button:hover { border-color:var(--danger); color:var(--danger); }
.events-list .empty { color:var(--muted); font-style:italic; }
.phases-panel {
  display:grid;
  gap:24px;
}
@media (max-width:900px) {
  .general-actions {
    width:100%;
    flex-direction:row;
    justify-content:flex-end;
  }
  .general-actions button {
    flex:1 1 auto;
  }
}
.switch-row { display:flex; align-items:center; gap:12px; }
.switch-row input[type="checkbox"] { width:50px; height:26px; border-radius:999px; appearance:none; background:rgba(255,255,255,.08); position:relative; cursor:pointer; }
.switch-row input[type="checkbox"]::after {
  content:"";
  position:absolute;
  top:3px; left:3px;
  width:20px; height:20px;
  border-radius:999px;
  background:#fff;
  transition:transform .2s ease;
}
.switch-row input[type="checkbox"]:checked { background:var(--accent); }
.switch-row input[type="checkbox"]:checked::after { transform:translateX(24px); background:#021221; }
.phase-table-wrapper {
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius-lg);
  overflow:auto;
  max-height:360px;
}
.param-table { width:100%; border-collapse:separate; border-spacing:0; min-width:520px; }
.param-table thead th {
  position:sticky;
  top:0;
  background:rgba(12,22,46,.95);
  text-align:left;
  z-index:1;
}
.param-table tbody tr { background:rgba(9,18,40,.6); }
.param-table td { border-bottom:1px solid rgba(255,255,255,.05); padding:10px 12px; }
.param-table tbody tr.dragging { opacity:.4; }
.row-tools { display:flex; gap:8px; }
.batch-actions { display:flex; flex-wrap:wrap; gap:10px; }
.import-group { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
textarea { background:rgba(15,26,52,.8); border:1px solid rgba(255,255,255,.12); border-radius:var(--radius); padding:12px; min-height:110px; }
summary { cursor:pointer; }
/* Analysis */
.analysis-grid { display:grid; gap:20px; }
@media (min-width:1280px) {
  .analysis-grid { grid-template-columns:400px minmax(0,1fr); }
}
.kpi-grid { display:grid; gap:12px; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); }
.kpi-card { background:rgba(9,18,40,.7); border-radius:var(--radius-lg); padding:16px; border:1px solid rgba(255,255,255,.08); display:grid; gap:6px; }
.kpi-card strong { font-size:1.3rem; font-variant-numeric:tabular-nums; }
.bar-chart { display:grid; gap:14px; }
.bar-row { display:grid; gap:6px; }
.bar-row .label { font-size:0.85rem; color:var(--muted); display:flex; justify-content:space-between; }
.bar-row .bar {
  height:12px;
  border-radius:999px;
  background:rgba(255,255,255,.08);
  overflow:hidden;
}
.bar-row .fill {
  height:100%;
  background:var(--accent);
  transition:width .3s ease;
}
.list-card { display:grid; gap:12px; }
.list-card ol, .list-card ul { margin:0; padding-left:20px; display:grid; gap:8px; }
.list-card li { font-size:0.9rem; }
.bad { color:var(--danger); }
.notice { padding:14px 16px; background:rgba(255,255,255,.08); border-radius:var(--radius); }
.quick-event-menu {
  position:absolute;
  background:rgba(15,26,52,.95);
  border:1px solid rgba(255,255,255,.12);
  border-radius:var(--radius);
  padding:8px;
  display:grid;
  gap:6px;
  min-width:220px;
  z-index:3000;
  box-shadow:var(--shadow);
}
.quick-event-menu button {
  background:transparent;
  border:1px solid rgba(255,255,255,.12);
  border-radius:var(--radius);
  padding:8px 10px;
  color:var(--fg);
  text-align:left;
  cursor:pointer;
}
.quick-event-menu button:hover,
.quick-event-menu button:focus-visible {
  border-color:var(--accent);
  color:var(--accent);
}
@media print {
  body { background:#fff; color:#000; }
  .app { display:block; }
  header, .nav-tabs, #fullscreen, .toast-container { display:none !important; }
  main { padding:0; }
  .panel { background:#fff !important; border:1px solid #ccc; box-shadow:none; }
  .page { display:block !IMPORTANT; }
  .ops-columns, .kpi-grid, .bar-chart { page-break-inside:avoid; }
}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="top-nav">
      <div class="brand">SMED L29</div>
      <div class="nav-tabs" role="tablist">
        <button type="button" data-target="timerPage" class="active" aria-controls="timerPage" aria-selected="true">Timer</button>
        <button type="button" data-target="paramsPage" aria-controls="paramsPage" aria-selected="false">Paramètres</button>
        <button type="button" data-target="analysisPage" aria-controls="analysisPage" aria-selected="false">Analyse</button>
      </div>
      <div class="header-actions">
        <button id="toggleJournal" class="ghost" type="button" aria-pressed="false" title="Afficher/Masquer Journal"><span class="icon">🗂</span>Masquer le journal</button>
        <button id="fullscreen" class="ghost" type="button" aria-label="Plein écran"><span class="icon">⤢</span>Plein écran</button>
      </div>
    </div>
  </header>
  <main>
    <section id="timerPage" class="page active" aria-labelledby="Timer">
      <div class="timer-grid">
        <div class="panel">
          <div class="timer-shell">
            <div class="id-row">
              <div class="field"><label>Ligne<input type="text" value="L29" readonly></label></div>
              <div class="field"><label>PO<input id="po" type="text" placeholder="Ordre de production"></label></div>
              <div class="field"><label>Mode<select id="mode"><option value="up">Chrono croissant</option><option value="down">Chrono décroissant</option></select></label></div>
            </div>
            <div class="timer-top">
              <div class="timer-bar">
                <div class="round-pill">
                  <span class="label-muted">Chronomètre</span>
                  <div id="display">00:00:00</div>
                  <div id="state">Prêt</div>
                </div>
                <div class="main-actions">
                  <button id="startPause" class="primary" type="button"><span class="icon">▶</span>Démarrer</button>
                  <button id="lap" class="secondary" type="button"><span class="icon">✦</span>Événement rapide</button>
                  <button id="markOp" class="secondary" type="button"><span class="icon">✓</span>Opération suivante</button>
                  <button id="end" class="warn" type="button"><span class="icon">■</span>Fin du changement</button>
                  <button id="reset" class="danger" type="button"><span class="icon">↺</span>Reset session</button>
                </div>
                <div class="round-pill">
                  <div class="label-muted">Références</div>
                  <strong><span id="targetMin">0</span> min</strong>
                  <span class="badge">Alerte <span id="warnMin">0</span> min</span>
                </div>
              </div>
              <div class="progress-bar" id="progress" aria-hidden="true"><div class="progress-value"></div></div>
              <div class="chip-row" id="phaseChips" role="tablist"></div>
              <div class="label-muted" id="now"></div>
            </div>
            <div class="ops-columns" id="opsPhaseChips"></div>
          </div>
        </div>
        <aside id="journalAside" class="panel compact">
          <div class="panel-title">
            <h2>Journal</h2>
            <div class="badge" id="logCount">0 entrées</div>
          </div>
          <div class="log-table-wrapper" role="region" aria-live="polite">
            <table>
              <thead>
                <tr>
                  <th>#</th>
                  <th>Horodatage</th>
                  <th>Durée</th>
                  <th>HC</th>
                  <th>Phase</th>
                  <th>Opérateur</th>
                  <th>Libellé</th>
                  <th>Note</th>
                </tr>
              </thead>
              <tbody id="logTable"></tbody>
              <tfoot>
                <tr>
                  <td colspan="2">Total chrono</td>
                  <td id="totalCell">00:00:00</td>
                  <td colspan="5"></td>
                </tr>
              </tfoot>
            </table>
          </div>
          <div class="actions-row" style="margin-top:16px;">
            <button id="exportCsv" class="ghost" type="button">Exporter CSV</button>
            <button id="exportHtml" class="ghost" type="button">Exporter rapport</button>
          </div>
        </aside>
      </div>
    </section>
    <section id="paramsPage" class="page" aria-labelledby="Paramètres">
      <div class="panel general-panel">
        <div class="panel-title"><h2>Paramètres généraux</h2><div class="badge">Auto-save actif</div></div>
        <div class="general-settings-bar">
          <div class="param-tile">
            <h3>Opérateurs</h3>
            <div class="field"><label>Opérateur 1<input type="text" id="op1"></label></div>
            <div class="field"><label>Opérateur 2<input type="text" id="op2"></label></div>
            <div class="field"><label>Opérateur 3<input type="text" id="op3"></label></div>
          </div>
          <div class="param-tile">
            <h3>Assignations</h3>
            <div class="field"><label>Opérateur par défaut<select id="defaultOperator"></select></label></div>
            <div class="switch-row"><input id="multiView" type="checkbox"><label for="multiView">Vue multi-opérateurs</label></div>
          </div>
          <div class="param-tile">
            <h3>Alerte</h3>
            <div class="field"><label>Alerte (min)<input type="number" step="0.5" id="alertInput"></label></div>
            <button id="suggestAlert" type="button" class="ghost">Suggérer 85 %</button>
          </div>
          <div class="general-actions">
            <button id="saveParams" class="primary" type="button">Sauvegarder</button>
            <button id="resetParams" class="danger" type="button">Réinitialiser</button>
          </div>
        </div>
      </div>
      <div class="panel compact events-panel">
        <div class="panel-title"><h2>Évènements prédéfinis</h2><span class="label-muted">Utilisés par l'événement rapide</span></div>
        <form id="eventForm" class="event-form">
          <div class="field">
            <label>Nouvel événement<input type="text" id="eventInput" placeholder="Libellé d'événement"></label>
          </div>
          <button type="submit" class="ghost">Ajouter</button>
        </form>
        <ul id="eventsList" class="events-list"></ul>
      </div>
      <div class="panel compact phases-panel">
        <div class="panel-title"><h2>Phases et opérations</h2><span class="label-muted">Glisser-déposer pour réordonner</span></div>
        <div id="phaseTables"></div>
      </div>
    </section>
    <section id="analysisPage" class="page" aria-labelledby="Analyse">
      <div class="panel">
        <div class="panel-title"><h2>Analyse</h2><button id="refreshAnalysis" class="ghost" type="button">Rafraîchir</button></div>
        <div class="analysis-grid">
          <div class="panel compact list-card">
            <div class="kpi-grid" id="kpiGrid"></div>
            <div class="list-card">
              <h3>Top contributeurs à l'écart</h3>
              <ol id="topContrib"></ol>
            </div>
            <div class="list-card">
              <h3>Top opérations longues</h3>
              <ol id="topOps"></ol>
            </div>
            <div class="list-card">
              <h3>Perturbateurs fréquents</h3>
              <ul id="perturbateurs"></ul>
            </div>
          </div>
          <div class="panel compact list-card">
            <div class="panel-title"><h3>Répartition par phases</h3><span id="phaseDistributionTarget" class="label-muted"></span></div>
            <div class="bar-chart" id="phaseDistribution"></div>
            <div class="panel-title"><h3>Répartition par opérateurs</h3><span id="operatorDistributionTarget" class="label-muted"></span></div>
            <div class="bar-chart" id="operatorDistribution"></div>
            <div class="panel-title"><h3>Prépa (HC)</h3><span class="label-muted">Checklist & notes</span></div>
            <div class="notice" id="prepaSummary"></div>
          </div>
        </div>
      </div>
    </section>
  </main>
</div>
<div class="toast-container" id="toastContainer" aria-live="polite"></div>
<script>
(() => {
  const STORAGE_KEY = 'smed_timer_v3';
  const SCHEMA_VERSION = 4;
  const phasesList = ['Prépa chgt de PO','Début de PO','Fin de PO','Vide de ligne'];
  const timedPhases = ['Début de PO','Fin de PO','Vide de ligne'];
  const DEFAULT_STATE = () => ({
    schema_version: SCHEMA_VERSION,
    site: '',
    line: 'L29',
    po: '',
    mode: 'up',
    operators: ['Opérateur A','', ''],
    defaultOperatorIndex: 0,
    multiView: true,
    events: [],
    phases: {
      'Prépa chgt de PO': [
        { name: 'Checklist sécurité', targetMin: 3, operatorIndex: 0 }
      ],
      'Début de PO': [
        { name: 'Arrêt ligne', targetMin: 4, operatorIndex: 0 },
        { name: 'Changement outillage', targetMin: 6, operatorIndex: 0 }
      ],
      'Fin de PO': [
        { name: 'Redémarrage', targetMin: 5, operatorIndex: 0 }
      ],
      'Vide de ligne': [
        { name: 'Nettoyage final', targetMin: 4, operatorIndex: 0 }
      ]
    },
    alertMin: 12,
    elapsedMs: 0,
    prepaElapsedMs: 0,
    paused: true,
    activePhase: 'Prépa chgt de PO',
    marks: [],
    sessionStart: Date.now(),
    runningSince: null,
    sessionElapsedMs: 0,
    completedOpsByOp: {},
    multiViewOverride: null
  });

  const els = {
    pages: document.querySelectorAll('.page'),
    navButtons: document.querySelectorAll('.nav-tabs button'),
    display: document.getElementById('display'),
    startPause: document.getElementById('startPause'),
    lap: document.getElementById('lap'),
    markOp: document.getElementById('markOp'),
    end: document.getElementById('end'),
    reset: document.getElementById('reset'),
    state: document.getElementById('state'),
    progress: document.getElementById('progress').querySelector('.progress-value'),
    targetMin: document.getElementById('targetMin'),
    warnMin: document.getElementById('warnMin'),
    mode: document.getElementById('mode'),
    po: document.getElementById('po'),
    now: document.getElementById('now'),
    logTable: document.getElementById('logTable'),
    totalCell: document.getElementById('totalCell'),
    exportCsv: document.getElementById('exportCsv'),
    exportHtml: document.getElementById('exportHtml'),
    fullscreen: document.getElementById('fullscreen'),
    toggleJournal: document.getElementById('toggleJournal'),
    phaseChips: document.getElementById('phaseChips'),
    opsPhaseChips: document.getElementById('opsPhaseChips'),
    saveParams: document.getElementById('saveParams'),
    resetParams: document.getElementById('resetParams'),
    refreshAnalysis: document.getElementById('refreshAnalysis'),
    logCount: document.getElementById('logCount'),
    toastContainer: document.getElementById('toastContainer'),
    alertInput: document.getElementById('alertInput'),
    suggestAlert: document.getElementById('suggestAlert'),
    defaultOperator: document.getElementById('defaultOperator'),
    opInputs: [document.getElementById('op1'), document.getElementById('op2'), document.getElementById('op3')],
    multiView: document.getElementById('multiView'),
    phaseTables: document.getElementById('phaseTables'),
    kpiGrid: document.getElementById('kpiGrid'),
    topContrib: document.getElementById('topContrib'),
    topOps: document.getElementById('topOps'),
    perturbateurs: document.getElementById('perturbateurs'),
    phaseDistribution: document.getElementById('phaseDistribution'),
    operatorDistribution: document.getElementById('operatorDistribution'),
    phaseDistributionTarget: document.getElementById('phaseDistributionTarget'),
    operatorDistributionTarget: document.getElementById('operatorDistributionTarget'),
    prepaSummary: document.getElementById('prepaSummary'),
    progressContainer: document.getElementById('progress'),
    eventForm: document.getElementById('eventForm'),
    eventInput: document.getElementById('eventInput'),
    eventsList: document.getElementById('eventsList')
  };

  let state = migrate(loadState());
  const runtime = {
    activePage: 'timerPage',
    animationFrame: null,
    lastTick: performance.now(),
    focusedOperator: state.defaultOperatorIndex || 0,
    journalHidden: false,
    analysisTimeout: null,
    shouldScrollToCurrent: false,
    quickEventMenu: null
  };

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return DEFAULT_STATE();
      return JSON.parse(raw);
    } catch (err) {
      console.error('Erreur de chargement, réinitialisation', err);
      return DEFAULT_STATE();
    }
  }

  function migrate(data) {
    const merged = Object.assign(DEFAULT_STATE(), data || {});
    merged.schema_version = SCHEMA_VERSION;
    merged.line = 'L29';
    merged.phases = merged.phases || DEFAULT_STATE().phases;
    merged.operators = merged.operators || ['', '', ''];
    while (merged.operators.length < 3) merged.operators.push('');
    merged.defaultOperatorIndex = typeof merged.defaultOperatorIndex === 'number' ? merged.defaultOperatorIndex : 0;
    merged.alertMin = Number.isFinite(merged.alertMin) ? merged.alertMin : 0;
    merged.marks = Array.isArray(merged.marks) ? merged.marks : [];
    merged.completedOpsByOp = merged.completedOpsByOp || {};
    merged.events = Array.isArray(merged.events)
      ? merged.events.map(label => typeof label === 'string' ? label.trim() : '').filter(label => label)
      : [];
    Object.keys(merged.completedOpsByOp).forEach(op => {
      const phases = merged.completedOpsByOp[op];
      Object.keys(phases).forEach(ph => {
        if (Array.isArray(phases[ph])) phases[ph] = new Set(phases[ph]);
        else if (!(phases[ph] instanceof Set)) phases[ph] = new Set(Object.values(phases[ph] || {}));
      });
    });
    merged.marks = merged.marks.map(m => ({
      t: m.t ?? 0,
      phase: m.phase || merged.activePhase || 'Prépa chgt de PO',
      operator: m.operator || undefined,
      label: m.label || '',
      kind: m.kind || 'event',
      note: m.note || '',
      hc: !!m.hc,
      durationMs: m.durationMs || 0
    }));
    if (!Number.isFinite(merged.elapsedMs)) merged.elapsedMs = 0;
    if (!Number.isFinite(merged.prepaElapsedMs)) merged.prepaElapsedMs = 0;
    if (!Number.isFinite(merged.sessionElapsedMs)) merged.sessionElapsedMs = 0;
    if (!merged.sessionStart) merged.sessionStart = Date.now();
    if (!('paused' in merged)) merged.paused = true;
    if (!merged.activePhase || !phasesList.includes(merged.activePhase)) merged.activePhase = 'Prépa chgt de PO';
    merged.multiView = merged.multiView ?? true;
    return merged;
  }

  function serializeState() {
    const copy = JSON.parse(JSON.stringify(state));
    copy.completedOpsByOp = {};
    Object.keys(state.completedOpsByOp).forEach(op => {
      copy.completedOpsByOp[op] = {};
      Object.keys(state.completedOpsByOp[op]).forEach(ph => {
        copy.completedOpsByOp[op][ph] = Array.from(state.completedOpsByOp[op][ph]);
      });
    });
    return copy;
  }

  function saveState(showToastFlag = false) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(serializeState()));
      if (showToastFlag) showToast('Paramètres enregistrés ✓');
    } catch (err) {
      console.error(err);
    }
  }

  function resetState() {
    state = DEFAULT_STATE();
    saveState();
    refreshAll();
    showToast('Réinitialisation effectuée');
  }

  function showToast(message, variant = 'success') {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.innerHTML = `<span class="icon">${variant === 'success' ? '✔' : variant === 'error' ? '⚠' : 'ℹ'}</span><span>${message}</span>`;
    els.toastContainer.appendChild(toast);
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(10px)';
    }, 20);
    setTimeout(() => toast.remove(), 4200);
  }

  function formatDuration(ms, showMillis = false) {
    const total = Math.max(0, Math.floor(ms / 1000));
    const h = String(Math.floor(total / 3600)).padStart(2,'0');
    const m = String(Math.floor((total % 3600) / 60)).padStart(2,'0');
    const s = String(total % 60).padStart(2,'0');
    if (!showMillis) return `${h}:${m}:${s}`;
    const cent = String(Math.floor((ms % 1000)/10)).padStart(2,'0');
    return `${h}:${m}:${s}.${cent}`;
  }

  function escapeHtml(value) {
    const entities = new Map([
      ['&', '&amp;'],
      ['<', '&lt;'],
      ['>', '&gt;'],
      ['"', '&quot;'],
      ['\'', '&#39;']
    ]);
    return String(value).replace(/[&<>"']/g, ch => entities.get(ch));
  }

  function targetMinutesForPhase(phase) {
    return (state.phases[phase] || []).reduce((sum, op) => sum + Number(op.targetMin || 0), 0);
  }
  function totalTargetMinutes() {
    return timedPhases.reduce((sum, phase) => sum + targetMinutesForPhase(phase), 0);
  }

  function updateTargets() {
    const target = totalTargetMinutes();
    els.targetMin.textContent = target.toFixed(1);
    els.warnMin.textContent = state.alertMin ? Number(state.alertMin).toFixed(1) : (target * 0.85).toFixed(1);
  }

  function ensureCompletedStructures() {
    for (let idx = 0; idx < state.operators.length; idx++) {
      const name = getCurrentOperatorName(idx);
      if (!state.completedOpsByOp[name]) state.completedOpsByOp[name] = {};
      phasesList.forEach(ph => {
        if (!(state.completedOpsByOp[name][ph] instanceof Set)) {
          state.completedOpsByOp[name][ph] = new Set(state.completedOpsByOp[name][ph] || []);
        }
      });
    }
  }

  function getCurrentOperatorName(index) {
    return state.operators[index] || `Opérateur ${index+1}`;
  }

  function renderPhaseChips() {
    els.phaseChips.innerHTML = '';
    phasesList.forEach(phase => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'phase-chip' + (state.activePhase === phase ? ' active' : '');
      btn.dataset.phase = phase;
      btn.innerHTML = `<span class="dot"></span><span>${phase}${phase === 'Prépa chgt de PO' ? ' (HC)' : ''}</span>`;
      btn.addEventListener('click', () => {
        changePhase(phase);
      });
      els.phaseChips.appendChild(btn);
    });
  }

  function renderOperatorColumns() {
    ensureCompletedStructures();
    els.opsPhaseChips.innerHTML = '';
    if (!Number.isInteger(runtime.focusedOperator)) runtime.focusedOperator = state.defaultOperatorIndex;
    if (runtime.focusedOperator < 0 || runtime.focusedOperator >= state.operators.length) runtime.focusedOperator = state.defaultOperatorIndex;
    if (!state.multiView) runtime.focusedOperator = state.defaultOperatorIndex;
    if (!state.operators[runtime.focusedOperator] && runtime.focusedOperator !== state.defaultOperatorIndex) {
      runtime.focusedOperator = state.defaultOperatorIndex;
    }
    state.operators.forEach((op, idx) => {
      if (!state.multiView && idx !== state.defaultOperatorIndex) return;
      if (!op && idx !== state.defaultOperatorIndex) return;
      const card = document.createElement('div');
      card.className = 'operator-card';
      card.dataset.index = idx;
      if (idx === runtime.focusedOperator) card.classList.add('focused');
      card.addEventListener('click', event => {
        if (event.target.closest('.op-pill')) return;
        runtime.focusedOperator = idx;
        renderOperatorColumns();
      });
      const operatorName = getCurrentOperatorName(idx);
      const phaseOps = (state.phases[state.activePhase] || []).filter(operation => {
        const assignedIndex = typeof operation.operatorIndex === 'number' ? operation.operatorIndex : state.defaultOperatorIndex;
        return assignedIndex === idx;
      });
      const completedSetForPhase = state.completedOpsByOp[operatorName][state.activePhase];
      const completed = completedSetForPhase.size || 0;
      const pct = phaseOps.length ? Math.round((completed/phaseOps.length)*100) : 0;
      card.innerHTML = `<div class="operator-header"><h3>${escapeHtml(operatorName)}</h3><span class="progress-text">${pct}%</span></div>`;
      const list = document.createElement('div');
      list.className = 'op-list';
      let firstPending = true;
      phaseOps.forEach((operation, opIndex) => {
        const pill = document.createElement('button');
        pill.type = 'button';
        pill.className = 'op-pill';
        const completedSet = completedSetForPhase;
        const isDone = completedSet.has(operation.name);
        if (isDone) pill.classList.add('done');
        if (!isDone && firstPending) {
          pill.classList.add('current');
          firstPending = false;
        }
        pill.innerHTML = `<span class="index">${opIndex + 1}</span><span>${escapeHtml(operation.name)}</span><span class="check">✔</span>`;
        pill.addEventListener('click', () => validateOperation(idx, operation));
        list.appendChild(pill);
      });
      if (!phaseOps.length) {
        const empty = document.createElement('div');
        empty.className = 'label-muted';
        empty.textContent = 'Aucune opération';
        list.appendChild(empty);
      }
      card.appendChild(list);
      els.opsPhaseChips.appendChild(card);
    });
    if (runtime.shouldScrollToCurrent) {
      runtime.shouldScrollToCurrent = false;
      requestAnimationFrame(scrollCurrentOperationIntoView);
    }
  }

  function scrollCurrentOperationIntoView() {
    if (!els.opsPhaseChips) return;
    const selector = `.operator-card[data-index="${runtime.focusedOperator}"] .op-pill.current`;
    const target = els.opsPhaseChips.querySelector(selector) || els.opsPhaseChips.querySelector('.op-pill.current');
    if (target) {
      target.scrollIntoView({ block: 'center', behavior: 'smooth' });
    }
  }

  function validateOperation(operatorIndex, operation) {
    runtime.focusedOperator = operatorIndex;
    const operatorName = getCurrentOperatorName(operatorIndex);
    ensureCompletedStructures();
    const completedSet = state.completedOpsByOp[operatorName][state.activePhase];
    if (completedSet.has(operation.name)) return;
    const previousTime = state.marks.length ? state.marks[state.marks.length-1].t : 0;
    const nowElapsed = getSessionElapsed();
    const duration = Math.max(0, nowElapsed - previousTime);
    completedSet.add(operation.name);
    state.marks.push({
      t: nowElapsed,
      phase: state.activePhase,
      operator: operatorName,
      label: operation.name,
      kind: 'op',
      note: '',
      hc: state.activePhase === 'Prépa chgt de PO',
      durationMs: duration
    });
    saveState();
    runtime.shouldScrollToCurrent = true;
    renderOperatorColumns();
    renderLog();
    updateAnalysisDelayed();
  }

  function changePhase(phase) {
    if (!phasesList.includes(phase)) return;
    if (state.activePhase === phase) return;
    const previousPhase = state.activePhase;
    if (!state.paused && state.runningSince) {
      const now = Date.now();
      const delta = now - state.runningSince;
      state.sessionElapsedMs += delta;
      if (previousPhase === 'Prépa chgt de PO') {
        state.prepaElapsedMs += delta;
      } else {
        state.elapsedMs += delta;
      }
      state.runningSince = now;
    }
    state.activePhase = phase;
    if (phase === 'Prépa chgt de PO') {
      els.startPause.disabled = true;
      els.startPause.classList.remove('primary');
      els.startPause.classList.add('secondary');
      els.state.textContent = 'Phase hors chrono';
    } else {
      els.startPause.disabled = false;
      els.startPause.classList.add('primary');
      els.startPause.classList.remove('secondary');
    }
    state.marks.push({
      t: getSessionElapsed(),
      phase,
      label: `Changement de phase vers ${phase}`,
      kind: 'event',
      hc: phase === 'Prépa chgt de PO'
    });
    renderPhaseChips();
    renderOperatorColumns();
    renderLog();
    updateDisplay();
    saveState();
    updateAnalysisDelayed();
  }

  function getSessionElapsed() {
    return state.sessionElapsedMs + (!state.paused && state.runningSince ? Date.now() - state.runningSince : 0);
  }

  function toggleTimer() {
    if (state.activePhase === 'Prépa chgt de PO') {
      showToast('Phase hors chrono : démarrage indisponible', 'info');
      return;
    }
    state.paused = !state.paused;
    if (!state.paused) {
      state.runningSince = Date.now();
      runtime.lastTick = performance.now();
      state.marks.push({
        t: getSessionElapsed(),
        phase: state.activePhase,
        label: 'Chrono démarré',
        kind: 'start',
        hc: false
      });
      els.startPause.innerHTML = '<span class="icon">⏸</span>Pause';
      requestTick();
      showToast('Chrono démarré');
    } else {
      const now = Date.now();
      if (state.runningSince) {
        const delta = now - state.runningSince;
        state.sessionElapsedMs += delta;
        if (state.activePhase === 'Prépa chgt de PO') {
          state.prepaElapsedMs += delta;
        } else {
          state.elapsedMs += delta;
        }
      }
      state.runningSince = null;
      els.startPause.innerHTML = '<span class="icon">▶</span>Démarrer';
      state.marks.push({
        t: getSessionElapsed(),
        phase: state.activePhase,
        label: 'Chrono en pause',
        kind: 'pause',
        hc: false
      });
      showToast('Chrono en pause');
    }
    saveState();
    renderLog();
    updateDisplay();
  }

  function requestTick() {
    cancelAnimationFrame(runtime.animationFrame);
    runtime.animationFrame = requestAnimationFrame(tick);
  }

  function tick(now) {
    runtime.lastTick = now;
    if (!state.paused) {
      updateDisplay();
      runtime.animationFrame = requestAnimationFrame(tick);
    }
  }

  function updateDisplay() {
    const targetMs = totalTargetMinutes()*60000;
    const currentElapsed = computeElapsedMs();
    const base = state.mode === 'down' ? Math.max(0, targetMs - currentElapsed) : currentElapsed;
    els.display.textContent = formatDuration(base);
    const warnMs = Number(state.alertMin || (totalTargetMinutes()*0.85))*60000;
    const pct = targetMs ? Math.min(100, (currentElapsed/targetMs)*100) : 0;
    els.progress.style.width = `${Math.min(100, pct)}%`;
    els.progress.style.background = currentElapsed <= warnMs ? 'var(--accent)' : currentElapsed <= targetMs ? 'var(--warn)' : 'var(--danger)';
    els.state.textContent = state.paused ? 'En pause' : 'En cours';
    els.targetMin.textContent = totalTargetMinutes().toFixed(1);
    els.warnMin.textContent = Number(state.alertMin || (totalTargetMinutes()*0.85)).toFixed(1);
  }

  function computeElapsedMs() {
    if (!state.paused && state.runningSince && state.activePhase !== 'Prépa chgt de PO') {
      return state.elapsedMs + (Date.now() - state.runningSince);
    }
    return state.elapsedMs;
  }

  function addEvent(label, options = {}) {
    state.marks.push({
      t: getSessionElapsed(),
      phase: state.activePhase,
      operator: options.operator,
      label,
      kind: options.kind || 'event',
      note: options.note || '',
      hc: state.activePhase === 'Prépa chgt de PO',
      durationMs: 0
    });
    saveState();
    renderLog();
    updateAnalysisDelayed();
  }

  function openQuickEventMenu() {
    if (runtime.quickEventMenu) {
      closeQuickEventMenu();
      return;
    }
    const available = state.events.filter(label => label && label.trim());
    if (!available.length) {
      const manual = prompt("Libellé de l'événement :");
      if (manual && manual.trim()) addEvent(manual.trim());
      return;
    }
    const menu = document.createElement('div');
    menu.className = 'quick-event-menu';
    menu.setAttribute('role', 'menu');
    available.forEach(label => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = label;
      btn.addEventListener('click', () => {
        addEvent(label);
        closeQuickEventMenu();
      });
      menu.appendChild(btn);
    });
    const custom = document.createElement('button');
    custom.type = 'button';
    custom.textContent = 'Autre…';
    custom.addEventListener('click', () => {
      const manual = prompt("Libellé de l'événement :");
      if (manual && manual.trim()) addEvent(manual.trim());
      closeQuickEventMenu();
    });
    menu.appendChild(custom);
    document.body.appendChild(menu);
    const rect = els.lap.getBoundingClientRect();
    menu.style.top = `${rect.bottom + window.scrollY + 8}px`;
    menu.style.left = `${rect.left + window.scrollX}px`;
    runtime.quickEventMenu = menu;
    document.addEventListener('click', handleQuickEventOutside, true);
    document.addEventListener('keydown', handleQuickEventKeydown);
    if (els.lap) els.lap.setAttribute('aria-expanded', 'true');
  }

  function closeQuickEventMenu() {
    if (!runtime.quickEventMenu) return;
    runtime.quickEventMenu.remove();
    runtime.quickEventMenu = null;
    document.removeEventListener('click', handleQuickEventOutside, true);
    document.removeEventListener('keydown', handleQuickEventKeydown);
    if (els.lap) els.lap.setAttribute('aria-expanded', 'false');
  }

  function handleQuickEventOutside(event) {
    if (!runtime.quickEventMenu) return;
    if (runtime.quickEventMenu.contains(event.target) || (els.lap && els.lap.contains(event.target))) return;
    closeQuickEventMenu();
  }

  function handleQuickEventKeydown(event) {
    if (event.key === 'Escape') {
      closeQuickEventMenu();
    }
  }

  function finishChange() {
    if (!state.marks.some(m => m.kind === 'end')) {
      addEvent('Fin du changement', { kind: 'end' });
      state.paused = true;
      if (state.runningSince) {
        const now = Date.now();
        const delta = now - state.runningSince;
        state.sessionElapsedMs += delta;
        if (state.activePhase === 'Prépa chgt de PO') {
          state.prepaElapsedMs += delta;
        } else {
          state.elapsedMs += delta;
        }
        state.runningSince = null;
      }
      els.startPause.innerHTML = '<span class="icon">▶</span>Démarrer';
      updateDisplay();
      showToast('Changement terminé');
    }
  }

  function renderLog() {
    els.logTable.innerHTML = '';
    let previousTime = 0;
    let totalChrono = 0;
    state.marks.sort((a,b) => a.t - b.t);
    state.marks.forEach((mark, index) => {
      const row = document.createElement('tr');
      const duration = mark.durationMs || Math.max(0, mark.t - previousTime);
      if (!mark.hc && mark.kind !== 'start') {
        totalChrono += duration;
      }
      row.innerHTML = `
        <td>${index + 1}</td>
        <td>${formatDuration(mark.t)}</td>
        <td>${formatDuration(duration)}</td>
        <td>${mark.hc ? '<span class="badge hc">HC</span>' : 'Non'}</td>
        <td>${escapeHtml(mark.phase)}</td>
        <td>${escapeHtml(mark.operator || '')}</td>
        <td>${escapeHtml(mark.label)}</td>
        <td class="note-cell" contenteditable="true" data-index="${index}">${escapeHtml(mark.note || '')}</td>
      `;
      els.logTable.appendChild(row);
      previousTime = mark.t;
    });
    els.totalCell.textContent = formatDuration(totalChrono);
    els.logCount.textContent = `${state.marks.length} entrées`;
  }

  function handleNoteEdit(event) {
    const cell = event.target;
    if (!cell.matches('[contenteditable="true"]')) return;
    const index = Number(cell.dataset.index);
    if (!Number.isFinite(index)) return;
    state.marks[index].note = cell.textContent.trim();
    saveState();
  }

  function exportCsv() {
    const target = totalTargetMinutes();
    const headers = ['date_session','line','po','mode','hors_chrono','target_min_global','idx','horodatage','duree_ms','duree_hms','operateur','phase','evenement','note'];
    const rows = state.marks.map((mark, idx) => [
      new Date(state.sessionStart).toISOString(),
      state.line,
      state.po,
      state.mode,
      mark.hc ? 'true' : 'false',
      target.toFixed(1),
      idx + 1,
      formatDuration(mark.t),
      Math.max(0, mark.durationMs || 0),
      formatDuration(mark.durationMs || 0),
      mark.operator || '',
      mark.phase,
      mark.label,
      mark.note || ''
    ]);
    const csv = [headers.join(';')].concat(rows.map(r => r.map(value => `"${String(value).replace(/"/g,'""')}"`).join(';'))).join('\n');
    downloadFile(`smed_l29_${Date.now()}.csv`, csv, 'text/csv');
  }

  function exportHtml() {
    const template = `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<title>Rapport SMED L29</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root{color-scheme:light;}
body{font-family:"Inter","Segoe UI",sans-serif;margin:40px;background:#f4f6fb;color:#0f1a34;}
.report-header{display:flex;justify-content:space-between;align-items:flex-start;gap:20px;border-bottom:2px solid #d6def0;padding-bottom:16px;margin-bottom:32px;}
.report-header h1{margin:0;font-size:26px;color:#0b1533;}
.report-header .meta{margin:4px 0 0;color:#5b6380;font-size:14px;}
.report-header .chip{background:#0b1533;color:#fff;padding:10px 18px;border-radius:999px;font-weight:600;}
.section{margin-bottom:32px;}
.section h2{margin:0 0 12px;font-size:20px;color:#0b1533;}
.kpi-grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));}
.kpi-card{background:#fff;border-radius:16px;padding:18px;border:1px solid #dbe3f6;box-shadow:0 10px 25px rgba(15,26,52,.08);}
.kpi-card span{font-size:12px;letter-spacing:0.08em;color:#6c7693;text-transform:uppercase;}
.kpi-card strong{display:block;margin-top:8px;font-size:20px;color:#0f1a34;}
.data-table{width:100%;border-collapse:collapse;margin-top:12px;}
.data-table th,.data-table td{border:1px solid #dbe3f6;padding:10px 12px;font-size:13px;text-align:left;}
.data-table th{background:#eef2fc;font-size:12px;letter-spacing:0.06em;text-transform:uppercase;color:#4c5675;}
.list-grid{display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));}
.list-grid article{background:#fff;border:1px solid #dbe3f6;border-radius:14px;padding:16px;display:grid;gap:10px;}
.list-grid h3{margin:0;font-size:15px;color:#0b1533;}
.list-grid ul{margin:0;padding-left:20px;display:grid;gap:6px;}
.list-grid li{color:#0f1a34;font-size:14px;}
.prepa-card{background:#fff;border:1px solid #dbe3f6;border-radius:16px;padding:18px;display:grid;gap:10px;}
.badge{display:inline-block;padding:4px 10px;border-radius:999px;background:#eef2fc;color:#3a4a7a;font-size:12px;}
.badge.hc{background:#ffe8cc;color:#ad5a00;}
.muted{color:#6c7693;font-style:italic;}
.journal-table{width:100%;border-collapse:collapse;margin-top:16px;}
.journal-table th,.journal-table td{border:1px solid #dbe3f6;padding:8px 10px;font-size:12px;text-align:left;}
.journal-table th{background:#eef2fc;letter-spacing:0.06em;text-transform:uppercase;color:#4c5675;}
.journal-table td .badge{font-size:11px;}
@media print{body{margin:20mm;background:#fff;color:#000;} .report-header{border-color:#c5cee4;} .kpi-card,.prepa-card,.list-grid article{box-shadow:none;} a{color:inherit;}}
</style>
</head>
<body>
${buildReportHtml()}
</body>
</html>`;
    downloadFile(`smed_l29_${Date.now()}.html`, template, 'text/html');
  }

  function downloadFile(filename, content, mime) {
    const blob = new Blob([content], { type: mime });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    URL.revokeObjectURL(link.href);
  }

  function buildReportHtml() {
    const analysis = computeAnalysis();
    const kpi = analysis.kpi;
    const sessionDate = new Date(state.sessionStart).toLocaleString('fr-FR', { hour12: false });
    const safePo = escapeHtml(state.po || '—');
    const safeLine = escapeHtml(state.line || 'Ligne');
    const modeLabel = state.mode === 'down' ? 'Chrono décroissant' : 'Chrono croissant';
    const targetMinutes = kpi.target ? (kpi.target / 60000).toFixed(1) : '0.0';
    const phasesRows = analysis.phases.length
      ? analysis.phases.map(item => `<tr><td>${escapeHtml(item.phase)}</td><td>${formatDuration(item.duration)}</td><td>${item.percent}%</td><td>${item.gap ? '+' + formatDuration(item.gap) : '—'}</td></tr>`).join('')
      : '<tr><td colspan="4" class="muted">Aucune phase chronométrée enregistrée</td></tr>';
    const operatorRows = analysis.operators.length
      ? analysis.operators.map(item => `<tr><td>${escapeHtml(item.operator)}</td><td>${formatDuration(item.duration)}</td><td>${item.percent}%</td></tr>`).join('')
      : '<tr><td colspan="3" class="muted">Aucun opérateur chronométré</td></tr>';
    const topContribList = analysis.topContrib.length
      ? analysis.topContrib.map(item => `<li>${escapeHtml(item.phase)} · +${formatDuration(item.gap)}</li>`).join('')
      : '<li class="muted">Aucun dépassement</li>';
    const topOpsList = analysis.topOps.length
      ? analysis.topOps.map(item => `<li>${escapeHtml(item.label)} (${escapeHtml(item.phase)}) – ${formatDuration(item.duration)}</li>`).join('')
      : '<li class="muted">—</li>';
    const perturbList = analysis.events.length
      ? analysis.events.map(item => `<li>${escapeHtml(item.label)} (${item.count})</li>`).join('')
      : '<li class="muted">Aucun événement récurrent</li>';
    const prepaNotes = analysis.prepa.notes.length
      ? `<ul>${analysis.prepa.notes.map(note => `<li>${escapeHtml(note)}</li>`).join('')}</ul>`
      : '<p class="muted">Aucun commentaire</p>';
    const journalRows = state.marks.length
      ? state.marks.map((mark, idx) => `<tr><td>${idx + 1}</td><td>${formatDuration(mark.t)}</td><td>${formatDuration(mark.durationMs || 0)}</td><td>${mark.hc ? '<span class="badge hc">HC</span>' : 'Non'}</td><td>${escapeHtml(mark.phase)}</td><td>${escapeHtml(mark.operator || '')}</td><td>${escapeHtml(mark.label)}</td><td>${escapeHtml(mark.note || '')}</td></tr>`).join('')
      : '<tr><td colspan="8" class="muted">Journal vide</td></tr>';
    return `
      <header class="report-header">
        <div>
          <h1>Rapport SMED – PO ${safePo}</h1>
          <p class="meta">Ligne ${safeLine} · ${modeLabel} · Session du ${sessionDate}</p>
        </div>
        <div class="chip">Cible globale : ${targetMinutes} min</div>
      </header>
      <section class="section">
        <h2>Indicateurs clés</h2>
        <div class="kpi-grid">
          <div class="kpi-card"><span>Durée totale</span><strong>${formatDuration(kpi.total)}</strong></div>
          <div class="kpi-card"><span>Cible (min)</span><strong>${targetMinutes}</strong></div>
          <div class="kpi-card"><span>Écart</span><strong>${formatDuration(kpi.gap)}</strong></div>
          <div class="kpi-card"><span>Gain potentiel</span><strong>${formatDuration(kpi.potential)}</strong></div>
        </div>
      </section>
      <section class="section">
        <h2>Répartition par phases</h2>
        <table class="data-table"><thead><tr><th>Phase</th><th>Durée</th><th>%</th><th>Écart vs cible</th></tr></thead><tbody>${phasesRows}</tbody></table>
      </section>
      <section class="section">
        <h2>Répartition par opérateurs</h2>
        <table class="data-table"><thead><tr><th>Opérateur</th><th>Durée</th><th>%</th></tr></thead><tbody>${operatorRows}</tbody></table>
      </section>
      <section class="section">
        <h2>Analyse qualitative</h2>
        <div class="list-grid">
          <article><h3>Top contributeurs à l'écart</h3><ul>${topContribList}</ul></article>
          <article><h3>Top opérations longues</h3><ul>${topOpsList}</ul></article>
          <article><h3>Perturbateurs fréquents</h3><ul>${perturbList}</ul></article>
        </div>
      </section>
      <section class="section">
        <h2>Prépa (HC)</h2>
        <div class="prepa-card">
          <div><span class="badge hc">HC</span> Checklist complétée à <strong>${analysis.prepa.percent}%</strong></div>
          <div>Temps total hors chrono : <strong>${formatDuration(analysis.prepa.duration)}</strong></div>
          <div>Commentaires :</div>
          ${prepaNotes}
        </div>
      </section>
      <section class="section">
        <h2>Journal des événements</h2>
        <table class="journal-table"><thead><tr><th>#</th><th>Horodatage</th><th>Durée</th><th>HC</th><th>Phase</th><th>Opérateur</th><th>Libellé</th><th>Note</th></tr></thead><tbody>${journalRows}</tbody></table>
      </section>
    `;
  }

  function computeAnalysis() {
    const phaseDurations = new Map();
    const operatorDurations = new Map();
    const events = new Map();
    let previousTime = 0;
    let totalChrono = 0;
    const gapSource = [];
    let phaseContext = state.marks.length ? state.marks[0].phase : state.activePhase;
    state.marks.forEach(mark => {
      const duration = mark.durationMs || Math.max(0, mark.t - previousTime);
      const isPhaseChange = mark.kind === 'event' && mark.label?.toLowerCase().includes('changement de phase');
      const attributedPhase = isPhaseChange ? phaseContext : mark.phase;
      const attributedHc = attributedPhase === 'Prépa chgt de PO';
      if (!attributedHc) {
        totalChrono += duration;
        phaseDurations.set(attributedPhase, (phaseDurations.get(attributedPhase) || 0) + duration);
        if (mark.operator) {
          operatorDurations.set(mark.operator, (operatorDurations.get(mark.operator) || 0) + duration);
        }
        if (mark.kind === 'op') {
          gapSource.push({ phase: attributedPhase, label: mark.label, duration });
        }
      }
      if (mark.kind === 'event' && mark.label && !isPhaseChange) {
        events.set(mark.label, (events.get(mark.label) || 0) + 1);
      }
      previousTime = mark.t;
      phaseContext = mark.phase;
    });
    const targetMs = totalTargetMinutes() * 60000;
    const gapMs = Math.max(0, totalChrono - targetMs);
    const potential = gapMs > 0 ? gapMs : Math.max(0, targetMs - totalChrono);
    const phases = Array.from(phaseDurations.entries()).filter(([phase]) => timedPhases.includes(phase)).map(([phase, duration]) => ({
      phase,
      duration,
      percent: totalChrono ? Math.round((duration/totalChrono)*100) : 0,
      gap: Math.max(0, duration - targetMinutesForPhase(phase)*60000)
    })).sort((a,b) => b.duration - a.duration);
    const operators = Array.from(operatorDurations.entries()).map(([operator,duration]) => ({
      operator,
      duration,
      percent: totalChrono ? Math.round((duration/totalChrono)*100) : 0
    })).sort((a,b) => b.duration - a.duration);
    const topContrib = phases.filter(p => p.gap > 0).sort((a,b) => b.gap - a.gap).slice(0,3);
    const topOps = gapSource.filter(item => timedPhases.includes(item.phase)).sort((a,b) => b.duration - a.duration).slice(0,3);
    const eventsList = Array.from(events.entries()).map(([label,count]) => ({ label, count })).sort((a,b) => b.count - a.count);
    const prepaMarks = state.marks.filter(m => m.phase === 'Prépa chgt de PO');
    const prepaCompleted = prepaMarks.filter(m => m.kind === 'op').length;
    const prepaTotal = (state.phases['Prépa chgt de PO'] || []).length || 1;
    return {
      kpi: {
        total: totalChrono,
        target: targetMs,
        gap: gapMs,
        potential
      },
      phases,
      operators,
      topContrib,
      topOps,
      events: eventsList,
      prepa: {
        percent: Math.round((prepaCompleted / prepaTotal) * 100),
        duration: state.prepaElapsedMs,
        notes: prepaMarks.map(m => m.note).filter(Boolean)
      }
    };
  }

  function renderAnalysis() {
    const analysis = computeAnalysis();
    const target = totalTargetMinutes();
    els.kpiGrid.innerHTML = `
      <div class="kpi-card"><span>Durée totale</span><strong>${formatDuration(analysis.kpi.total)}</strong></div>
      <div class="kpi-card"><span>Cible (min)</span><strong>${target.toFixed(1)}</strong></div>
      <div class="kpi-card"><span>Écart</span><strong class="${analysis.kpi.gap>0 ? 'bad' : ''}">${formatDuration(analysis.kpi.gap)}</strong></div>
      <div class="kpi-card"><span>Gain potentiel</span><strong>${formatDuration(analysis.kpi.potential)}</strong></div>
    `;
    els.phaseDistribution.innerHTML = '';
    analysis.phases.forEach(item => {
      const row = document.createElement('div');
      row.className = 'bar-row';
      row.innerHTML = `<div class="label"><span>${escapeHtml(item.phase)}</span><span>${formatDuration(item.duration)} · ${item.percent}%</span></div><div class="bar"><div class="fill" style="width:${item.percent}%;"></div></div>`;
      els.phaseDistribution.appendChild(row);
    });
    els.phaseDistributionTarget.textContent = `Cible ${(target).toFixed(1)} min`;
    els.operatorDistribution.innerHTML = '';
    analysis.operators.forEach(item => {
      const row = document.createElement('div');
      row.className = 'bar-row';
      row.innerHTML = `<div class="label"><span>${escapeHtml(item.operator)}</span><span>${formatDuration(item.duration)} · ${item.percent}%</span></div><div class="bar"><div class="fill" style="width:${item.percent}%;"></div></div>`;
      els.operatorDistribution.appendChild(row);
    });
    els.operatorDistributionTarget.textContent = `${analysis.operators.length} opérateurs`;
    if (analysis.topContrib.length) {
      els.topContrib.innerHTML = analysis.topContrib.map(item => `<li>${escapeHtml(item.phase)} (+${formatDuration(item.gap)})</li>`).join('');
    } else {
      els.topContrib.innerHTML = '<li>Aucun dépassement</li>';
    }
    els.topOps.innerHTML = analysis.topOps.length ? analysis.topOps.map(item => `<li>${escapeHtml(item.label)} (${formatDuration(item.duration)})</li>`).join('') : '<li>—</li>';
    els.perturbateurs.innerHTML = analysis.events.length ? analysis.events.map(e => `<li>${escapeHtml(e.label)} (${e.count})</li>`).join('') : '<li>—</li>';
    const prepaNotesHtml = analysis.prepa.notes.length
      ? `<ul>${analysis.prepa.notes.map(note => `<li>${escapeHtml(note)}</li>`).join('')}</ul>`
      : '<span class="label-muted">Aucun commentaire</span>';
    els.prepaSummary.innerHTML = `
      <div><strong>${analysis.prepa.percent}%</strong> de la checklist complétée</div>
      <div>Temps total HC: ${formatDuration(analysis.prepa.duration)}</div>
      <div>Commentaires:<br>${prepaNotesHtml}</div>
    `;
  }

  function buildPhaseTables() {
    els.phaseTables.innerHTML = '';
    phasesList.forEach(phase => {
      const section = document.createElement('section');
      section.className = 'section-group';
      const isHC = phase === 'Prépa chgt de PO';
      section.innerHTML = `
        <details open>
          <summary><strong>${phase}</strong> ${isHC ? '<span class="badge hc">HC</span>' : ''}</summary>
          <div class="batch-actions">
            <button type="button" class="ghost" data-phase="${phase}" data-action="add">Ajouter une opération</button>
            <button type="button" class="ghost" data-phase="${phase}" data-action="assign">Définir opérateur</button>
            <button type="button" class="ghost" data-phase="${phase}" data-action="time">Définir temps</button>
            <label class="import-group">Importer CSV<input type="file" data-phase="${phase}" accept=".csv" style="display:none"></label>
            <button type="button" class="ghost" data-phase="${phase}" data-action="export-csv">Exporter CSV</button>
            <button type="button" class="ghost" data-phase="${phase}" data-action="export-json">Exporter JSON</button>
          </div>
          <div class="phase-table-wrapper">
            <table class="param-table" data-phase="${phase}">
              <thead>
                <tr><th></th><th>Opération</th><th>Temps cible (min)</th><th>Opérateur</th><th></th></tr>
              </thead>
              <tbody></tbody>
              <tfoot><tr><td colspan="5">Σ ${phase}: <strong class="phase-total">0 min</strong></td></tr></tfoot>
            </table>
          </div>
        </details>
      `;
      els.phaseTables.appendChild(section);
      const tbody = section.querySelector('tbody');
      const table = section.querySelector('table');
      (state.phases[phase] || []).forEach((operation, index) => {
        tbody.appendChild(buildPhaseRow(phase, operation, index));
      });
      updatePhaseTotal(table, phase);
      section.addEventListener('change', handlePhaseInputChange);
      section.querySelectorAll('button[data-phase]').forEach(btn => btn.addEventListener('click', handlePhaseAction));
      const fileInput = section.querySelector('input[type="file"]');
      fileInput.addEventListener('change', handleImportCsv);
      enableDragAndDrop(tbody, phase);
    });
  }

  function buildPhaseRow(phase, operation, index) {
    const tr = document.createElement('tr');
    tr.draggable = true;
    tr.innerHTML = `
      <td><input type="checkbox" data-select="${index}"></td>
      <td><input type="text" data-field="name" value="${escapeHtml(operation.name || '')}"></td>
      <td><input type="number" step="0.5" min="0" data-field="targetMin" value="${operation.targetMin || 0}"></td>
      <td><select data-field="operatorIndex"></select></td>
      <td class="row-tools"><button type="button" class="ghost" data-action="delete">Suppr.</button></td>
    `;
    const select = tr.querySelector('select');
    populateOperatorSelect(select, operation.operatorIndex);
    tr.querySelector('[data-action="delete"]').addEventListener('click', () => {
      const idx = Array.from(tr.parentElement.children).indexOf(tr);
      state.phases[phase].splice(idx,1);
      saveState(true);
      buildPhaseTables();
      renderOperatorColumns();
      updateTargets();
      updateAnalysisDelayed();
    });
    return tr;
  }

  function populateOperatorSelect(select, selectedIndex) {
    select.innerHTML = '';
    state.operators.forEach((op, idx) => {
      if (!op && idx > 0) return;
      const option = document.createElement('option');
      option.value = idx;
      option.textContent = op || `Opérateur ${idx+1}`;
      if (idx === (typeof selectedIndex === 'number' ? selectedIndex : state.defaultOperatorIndex)) option.selected = true;
      select.appendChild(option);
    });
  }

  function handlePhaseInputChange(event) {
    const input = event.target;
    const row = input.closest('tr');
    if (!row) return;
    const phase = input.closest('table').dataset.phase;
    const idx = Array.from(row.parentElement.children).indexOf(row);
    const field = input.dataset.field;
    if (!field) return;
    if (field === 'name') {
      state.phases[phase][idx][field] = input.value;
    } else {
      const numeric = Number(input.value);
      if (field === 'operatorIndex') {
        state.phases[phase][idx][field] = Number.isFinite(numeric) ? numeric : state.defaultOperatorIndex;
      } else {
        state.phases[phase][idx][field] = Number.isFinite(numeric) ? numeric : 0;
      }
    }
    saveState();
    updatePhaseTotal(input.closest('table'), phase);
    updateTargets();
    renderOperatorColumns();
    updateAnalysisDelayed();
  }

  function handlePhaseAction(event) {
    const btn = event.currentTarget;
    const phase = btn.dataset.phase;
    const action = btn.dataset.action;
    if (action === 'add') {
      state.phases[phase].push({ name: 'Nouvelle opération', targetMin: 1, operatorIndex: state.defaultOperatorIndex });
      saveState(true);
      buildPhaseTables();
      renderOperatorColumns();
      updateTargets();
      return;
    }
    const table = els.phaseTables.querySelector(`table[data-phase="${phase}"]`);
    const selected = Array.from(table.querySelectorAll('tbody tr')).filter(row => row.querySelector('input[type="checkbox"]').checked);
    if (action === 'assign') {
      const operator = prompt('Index opérateur (1-3) :', state.defaultOperatorIndex + 1);
      const idx = Number(operator) - 1;
      if (!Number.isInteger(idx) || idx < 0 || idx > 2) return;
      selected.forEach(row => {
        const rowIndex = Array.from(row.parentElement.children).indexOf(row);
        state.phases[phase][rowIndex].operatorIndex = idx;
      });
      saveState();
      buildPhaseTables();
      renderOperatorColumns();
    }
    if (action === 'time') {
      const value = Number(prompt('Temps cible (min) :', 1));
      if (!Number.isFinite(value)) return;
      selected.forEach(row => {
        const rowIndex = Array.from(row.parentElement.children).indexOf(row);
        state.phases[phase][rowIndex].targetMin = value;
      });
      saveState();
      buildPhaseTables();
      renderOperatorColumns();
      updateTargets();
    }
    if (action === 'export-csv') {
      const rows = state.phases[phase].map(op => `${op.name};${op.targetMin};${getCurrentOperatorName(op.operatorIndex || 0)}`);
      downloadFile(`phase_${phase.replace(/\s+/g,'_')}.csv`, ['operation;temps_min;operateur'].concat(rows).join('\n'), 'text/csv');
    }
    if (action === 'export-json') {
      downloadFile(`phase_${phase.replace(/\s+/g,'_')}.json`, JSON.stringify(state.phases[phase], null, 2), 'application/json');
    }
  }

  function handleImportCsv(event) {
    const input = event.target;
    const phase = input.dataset.phase;
    const file = input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = e => {
      const text = e.target.result;
      const lines = text.split(/\r?\n/).filter(Boolean);
      const entries = lines.slice(1).map(line => {
        if (!line.trim()) return null;
        const [name, time, operator] = line.split(';');
        const cleanedName = (name || '').trim();
        const numeric = Number.parseFloat((time || '').replace(',', '.'));
        const operatorLabel = (operator || '').trim().toLowerCase();
        const matchedIndex = state.operators.findIndex(op => (op || '').trim().toLowerCase() === operatorLabel && operatorLabel);
        const operatorIndex = matchedIndex >= 0 ? matchedIndex : state.defaultOperatorIndex;
        return {
          name: cleanedName || 'Opération',
          targetMin: Number.isFinite(numeric) ? numeric : 0,
          operatorIndex
        };
      }).filter(Boolean);
      if (entries.length) {
        state.phases[phase] = entries;
        saveState(true);
        buildPhaseTables();
        renderOperatorColumns();
        updateTargets();
        updateAnalysisDelayed();
      }
    };
    reader.readAsText(file, 'utf-8');
    input.value = '';
  }

  function updatePhaseTotal(table, phase) {
    const total = state.phases[phase].reduce((sum, op) => sum + Number(op.targetMin || 0), 0);
    const cell = table.querySelector('.phase-total');
    if (cell) cell.textContent = `${total.toFixed(1)} min`;
  }

  function enableDragAndDrop(tbody, phase) {
    let dragged;
    tbody.addEventListener('dragstart', event => {
      dragged = event.target;
      dragged.classList.add('dragging');
      event.dataTransfer.effectAllowed = 'move';
    });
    tbody.addEventListener('dragend', event => {
      event.target.classList.remove('dragging');
      dragged = null;
    });
    tbody.addEventListener('dragover', event => {
      event.preventDefault();
      const after = getDragAfterElement(tbody, event.clientY);
      if (!after) {
        tbody.appendChild(dragged);
      } else {
        tbody.insertBefore(dragged, after);
      }
    });
    tbody.addEventListener('drop', () => {
      const rows = Array.from(tbody.querySelectorAll('tr'));
      state.phases[phase] = rows.map(row => {
        const idx = Array.from(row.parentElement.children).indexOf(row);
        return {
          name: row.querySelector('input[data-field="name"]').value,
          targetMin: Number(row.querySelector('input[data-field="targetMin"]').value) || 0,
          operatorIndex: Number(row.querySelector('select[data-field="operatorIndex"]').value)
        };
      });
      saveState();
      renderOperatorColumns();
      updateTargets();
      updateAnalysisDelayed();
    });
  }

  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('tr:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  function buildDefaultsForm() {
    state.operators.forEach((op, idx) => {
      els.opInputs[idx].value = op;
    });
    els.defaultOperator.innerHTML = '';
    state.operators.forEach((op, idx) => {
      if (!op && idx > 0) return;
      const option = document.createElement('option');
      option.value = idx;
      option.textContent = op || `Opérateur ${idx+1}`;
      if (idx === state.defaultOperatorIndex) option.selected = true;
      els.defaultOperator.appendChild(option);
    });
    els.alertInput.value = state.alertMin;
    els.multiView.checked = !!state.multiView;
  }

  function renderEventsList() {
    if (!els.eventsList) return;
    els.eventsList.innerHTML = '';
    const events = state.events.filter(label => label && label.trim());
    if (!events.length) {
      const empty = document.createElement('li');
      empty.className = 'empty';
      empty.textContent = 'Aucun événement enregistré';
      els.eventsList.appendChild(empty);
      return;
    }
    events.forEach((label, index) => {
      const item = document.createElement('li');
      const span = document.createElement('span');
      span.textContent = label;
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.dataset.index = index;
      btn.textContent = 'Suppr.';
      btn.addEventListener('click', () => removePresetEvent(index));
      item.append(span, btn);
      els.eventsList.appendChild(item);
    });
  }

  function removePresetEvent(index) {
    if (!Number.isInteger(index)) return;
    state.events.splice(index, 1);
    saveState();
    renderEventsList();
    closeQuickEventMenu();
  }

  function handleEventFormSubmit(event) {
    event.preventDefault();
    if (!els.eventInput) return;
    const value = els.eventInput.value.trim();
    if (!value) return;
    state.events.push(value);
    els.eventInput.value = '';
    saveState(true);
    renderEventsList();
  }

  function refreshAll() {
    els.po.value = state.po;
    els.mode.value = state.mode;
    renderPhaseChips();
    renderOperatorColumns();
    updateTargets();
    updateDisplay();
    renderLog();
    buildPhaseTables();
    buildDefaultsForm();
    renderEventsList();
    renderAnalysis();
    if (state.activePhase === 'Prépa chgt de PO') {
      els.startPause.disabled = true;
      els.startPause.classList.remove('primary');
      els.startPause.classList.add('secondary');
    } else {
      els.startPause.disabled = false;
      els.startPause.classList.add('primary');
      els.startPause.classList.remove('secondary');
    }
    els.startPause.innerHTML = state.paused ? '<span class="icon">▶</span>Démarrer' : '<span class="icon">⏸</span>Pause';
    if (!state.paused && state.runningSince) {
      requestTick();
    }
  }

  function updateAnalysisDelayed() {
    clearTimeout(runtime.analysisTimeout);
    runtime.analysisTimeout = setTimeout(renderAnalysis, 350);
  }

  function bindEvents() {
    els.navButtons.forEach(btn => btn.addEventListener('click', () => switchPage(btn.dataset.target, btn)));
    els.startPause.addEventListener('click', toggleTimer);
    els.lap.setAttribute('aria-haspopup', 'menu');
    els.lap.setAttribute('aria-expanded', 'false');
    els.lap.addEventListener('click', openQuickEventMenu);
    els.markOp.addEventListener('click', () => {
      if (state.activePhase === 'Prépa chgt de PO') {
        showToast('Checklist Prépa (HC) : validation sans impact chrono', 'info');
      }
      ensureCompletedStructures();
      const ops = state.phases[state.activePhase] || [];
      const operatorIndex = runtime.focusedOperator;
      const nextOp = ops.find(op => (op.operatorIndex ?? state.defaultOperatorIndex) === operatorIndex && !state.completedOpsByOp[getCurrentOperatorName(operatorIndex)]?.[state.activePhase]?.has(op.name));
      if (nextOp) validateOperation(operatorIndex, nextOp);
    });
    els.end.addEventListener('click', finishChange);
    els.reset.addEventListener('click', () => {
      if (confirm('Réinitialiser la session ?')) {
        state.marks = [];
        state.elapsedMs = 0;
        state.prepaElapsedMs = 0;
        state.sessionElapsedMs = 0;
        state.runningSince = null;
        state.paused = true;
        els.startPause.innerHTML = '<span class="icon">▶</span>Démarrer';
        saveState(true);
        refreshAll();
      }
    });
    els.exportCsv.addEventListener('click', exportCsv);
    els.exportHtml.addEventListener('click', exportHtml);
    els.logTable.addEventListener('input', handleNoteEdit);
    els.mode.addEventListener('change', () => { state.mode = els.mode.value; saveState(); updateDisplay(); });
    els.po.addEventListener('input', () => { state.po = els.po.value; saveState(); });
    els.fullscreen.addEventListener('click', toggleFullscreen);
    if (els.toggleJournal) {
      els.toggleJournal.addEventListener('click', () => toggleJournalVisibility());
    }
    els.saveParams.addEventListener('click', () => { saveState(true); });
    els.resetParams.addEventListener('click', () => { if (confirm('Réinitialiser toutes les phases ?')) resetState(); });
    els.refreshAnalysis.addEventListener('click', renderAnalysis);
    els.alertInput.addEventListener('change', () => { state.alertMin = Number(els.alertInput.value); saveState(); updateTargets(); updateDisplay(); });
    els.suggestAlert.addEventListener('click', () => {
      const suggestion = Math.max(0, totalTargetMinutes() * 0.85);
      const rounded = Math.round(suggestion * 2) / 2;
      const displayValue = Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
      els.alertInput.value = displayValue;
      state.alertMin = rounded;
      saveState(true);
      updateTargets();
      updateDisplay();
    });
    els.defaultOperator.addEventListener('change', () => {
      state.defaultOperatorIndex = Number(els.defaultOperator.value);
      saveState();
      renderOperatorColumns();
      renderPhaseChips();
      updateAnalysisDelayed();
    });
    els.opInputs.forEach((input, idx) => {
      input.addEventListener('input', () => {
        const previousName = getCurrentOperatorName(idx);
        state.operators[idx] = input.value;
        const newName = getCurrentOperatorName(idx);
        if (previousName !== newName && state.completedOpsByOp[previousName]) {
          state.completedOpsByOp[newName] = state.completedOpsByOp[previousName];
          delete state.completedOpsByOp[previousName];
        }
        if (previousName !== newName) {
          state.marks.forEach(mark => {
            if (mark.operator === previousName) {
              mark.operator = newName;
            }
          });
        }
        ensureCompletedStructures();
        saveState();
        buildDefaultsForm();
        renderOperatorColumns();
      });
    });
    els.multiView.addEventListener('change', () => {
      state.multiView = els.multiView.checked;
      saveState();
      renderOperatorColumns();
    });
    if (els.eventForm) {
      els.eventForm.addEventListener('submit', handleEventFormSubmit);
    }
    document.addEventListener('keydown', handleShortcuts);
  }

  function toggleJournalVisibility(force) {
    const shouldHide = typeof force === 'boolean' ? force : !runtime.journalHidden;
    runtime.journalHidden = shouldHide;
    document.body.classList.toggle('journal-hidden', runtime.journalHidden);
    if (els.toggleJournal) {
      els.toggleJournal.setAttribute('aria-pressed', runtime.journalHidden ? 'true' : 'false');
      els.toggleJournal.title = 'Afficher/Masquer Journal';
      els.toggleJournal.innerHTML = `<span class="icon">🗂</span>${runtime.journalHidden ? 'Afficher le journal' : 'Masquer le journal'}`;
    }
  }

  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(() => showToast('Impossible de passer en plein écran', 'error'));
    } else {
      document.exitFullscreen();
    }
  }

  function handleShortcuts(event) {
    if (event.target && ['INPUT','TEXTAREA','SELECT'].includes(event.target.tagName)) return;
    if (event.code === 'Space') {
      event.preventDefault();
      toggleTimer();
    }
    if (event.key.toLowerCase() === 'e') {
      event.preventDefault();
      els.markOp.click();
    }
    if (event.key.toLowerCase() === 'l') {
      event.preventDefault();
      els.lap.click();
    }
    if (event.key.toLowerCase() === 'j') {
      event.preventDefault();
      toggleJournalVisibility();
    }
    if (['1','2','3'].includes(event.key)) {
      runtime.focusedOperator = Number(event.key) - 1;
      renderOperatorColumns();
    }
  }

  function switchPage(pageId, btn) {
    closeQuickEventMenu();
    runtime.activePage = pageId;
    els.pages.forEach(page => page.classList.toggle('active', page.id === pageId));
    els.navButtons.forEach(nav => nav.classList.toggle('active', nav === btn));
    renderAnalysis();
  }

  function updateClock() {
    els.now.textContent = new Date().toLocaleString('fr-FR', { hour12: false });
    requestAnimationFrame(updateClock);
  }

  bindEvents();
  toggleJournalVisibility(runtime.journalHidden);
  refreshAll();
  updateClock();
  renderAnalysis();
})();
</script>
</body>
</html>
